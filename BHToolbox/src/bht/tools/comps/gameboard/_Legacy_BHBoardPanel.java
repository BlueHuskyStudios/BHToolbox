/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * _Legacy_BHBoardPanel.java
 *
 * Created on Apr 13, 2011, 1:03:00 PM
 */
package bht.tools.comps.gameboard;

import bht.tools.util.ArrayPP;
import bht.tools.util.ArrayTable;
import java.awt.GridBagConstraints;

/**
 *
 * @author Supuhstar
 * @deprecated Use {@link BHBoardPanel}, instead
 */
class _Legacy_BHBoardPanel extends java.awt.Container
{
  private static final byte TOP = BHBoardSquare.STATE_TOP_OPEN,
                                  BOTTOM = BHBoardSquare.STATE_BOTTOM_OPEN,
                                  LEFT = BHBoardSquare.STATE_LEFT_OPEN,
                                  RIGHT = BHBoardSquare.STATE_RIGHT_OPEN;
  
  /** Creates new _Legacy_BHBoardPanel
   * @param width an {@code int} that represents the number of columns of squares in the board
   * @param height an {@code int} that represents the number of rows of squares in the board
   */
  public _Legacy_BHBoardPanel(int width, int height)
  {
    this(new java.awt.Dimension(width, height));
  }
  /** Creates new _Legacy_BHBoardPanel
   * @param numSquares a {@code java.awt.Dimension} that represents the number of squares in the board, given a certain height
   * and width
   */
  public _Legacy_BHBoardPanel(java.awt.Dimension numSquares)
  {
    String c = getClass().getName();
    System.out.println(c + ": Creating a BoardPanel " + numSquares.width + " squares wide and " + numSquares.height + " high...");
    initComponents();
    BHBoardSquare board[][] = new BHBoardSquare[numSquares.height][numSquares.width];
    for (int h = 0; h < numSquares.height; h++)
    {
      for (int w = 0; w < numSquares.width; w++)
      {
        final int W = w, H = h;
        board[h][w] = new BHBoardSquare();
        // Testing code:
        board[h][w].addActionListener(new java.awt.event.ActionListener() 
        {
          @Override
          public void actionPerformed(java.awt.event.ActionEvent e)
          {
            System.out.println("Clicked (" + W + ", " + H + ")");
          }
        });
        board[h][w].setText("(" + W + ", " + H + ")");//
      }
    }
    
    boardTable = new ArrayTable<>(board);
    
    loadSquares();
  }
  
  /**
   * Creates a new {@code _Legacy_BHBoardPanel} based on an {@code bht.tools.utilities.ArrayTable&lt;_Legacy_BHBoardSquare&gt;}
   * @param a the {@code bht.tools.utilities.ArrayTable&lt;_Legacy_BHBoardSquare&gt;} on which the new {@code _Legacy_BHBoardPanel} will be based
   */
  public _Legacy_BHBoardPanel(ArrayTable<BHBoardSquare> a)
  {
    initComponents();
    boardTable = a;
    
//    loadSquares();
  }
  
  private java.awt.Container getThis()
  {
    return this;
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.GridBagLayout());
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
  private ArrayTable<BHBoardSquare> boardTable;

  public void loadSquares()
  {
    removeAll();
//    setLayout(new java.awt.GridLayout(boardTable.getNumRows(),boardTable.getNumCols()));
    java.awt.GridBagConstraints gbc = new GridBagConstraints();
    gbc.fill = GridBagConstraints.BOTH;
    gbc.weightx = 1;
    gbc.weighty = 1;
    gbc.gridheight = 1;
    gbc.gridwidth = 1;
    gbc.anchor = GridBagConstraints.CENTER;

    System.out.println("Adding a table of size " + boardTable.getSize());
    for (int y = 0, yl=boardTable.getNumRows(); y < yl; y++)
    {
      for(int x = 0, xl=boardTable.getNumCols(); x < xl; x++)
      {
        gbc.gridx = x;
        gbc.gridy = y;
        System.out.println("Adding square (" + x + "," + y + ")");
        add(boardTable.getCell(x, y), gbc);
      }
    }
  }
  
  public BHBoardSquare getSquare(int x, int y)
  {
    return boardTable.getCell(x, y);
  }
  
  public ArrayTable<BHBoardSquare> getArrayTable()
  {
    return boardTable;
  }

  /**
   * Opens a square to the one next to it ("next to" is defined by the provided {@code byte} mask)
   * @param x the x-coordinate of the target square (where the top-left is (0,0))
   * @param y the y-coordinate of the target square (where the top-left is (0,0))
   * @param sideMask a {@code byte} mask representing the side of the square to be opened
   * @return {@code this}
   * @throws IllegalArgumentException if the given {@code byte} mask is not {@link TOP}, {@link BOTTOM}, {@link LEFT}, or
   * {@code link}
   * @see #TOP
   * @see #BOTTOM
   * @see #LEFT
   * @see #RIGHT
   */
  public _Legacy_BHBoardPanel openSquare(int x, int y, byte sideMask)
  {
    switch (sideMask)
    {
      case LEFT:
        if (x > 0)
          getSquare(x - 1, y).openSides(RIGHT);
        break;

      case RIGHT:
        if (x < getNumCols() - 1)
          getSquare(x + 1, y).openSides(LEFT);
        break;

      case TOP:
        if (y > 0)
          getSquare(x, y - 1).openSides(BOTTOM);
        break;

      case BOTTOM:
        if (y < getNumRows() - 1)
          getSquare(x, y + 1).openSides(TOP);
        break;

      default:
        throw new IllegalArgumentException("Unrecognized byte mask: " + sideMask);
    }

    getSquare(x, y).openSides(sideMask);
    return this;
  }

  /**
   * Closes square(s) to the one next to it (the side to be closed is defined by the provided {@code byte} mask)
   * @param x the x-coordinate of the target square (where the top-left is (0,0))
   * @param y the y-coordinate of the target square (where the top-left is (0,0))
   * @param sideMask a {@code byte} mask representing the side of the square to be opened
   * @return {@code this}
   * @throws IllegalArgumentException if the given {@code byte} mask is not {@link TOP}, {@link BOTTOM}, {@link LEFT}, or
   * {@code link}
   * @see #TOP
   * @see #BOTTOM
   * @see #LEFT
   * @see #RIGHT
   */
  public _Legacy_BHBoardPanel closeSquare(int x, int y, byte sideMask)
  {
    switch (sideMask)
    {
      case LEFT:
        if (x > 0)
          getSquare(x - 1, y).closeSides(RIGHT);
        break;

      case RIGHT:
        if (x < getNumCols() - 1)
          getSquare(x + 1, y).closeSides(LEFT);
        break;

      case TOP:
        if (y > 0)
          getSquare(x, y - 1).closeSides(BOTTOM);
        break;

      case BOTTOM:
        if (y < getNumRows() - 1)
          getSquare(x, y + 1).closeSides(TOP);
        break;

      default:
        throw new IllegalArgumentException("Unrecognized byte mask: " + sideMask);
    }

    getSquare(x, y).closeSides(sideMask);
    return this;
  }

  public int getNumRows()
  {
    return boardTable.getNumRows();
  }

  public int getNumCols()
  {
    return boardTable.getNumCols();
  }

  /**
   * Resizes the board to fit the given parameters
   * @param width the target number of columns in the board
   * @param height the target number of rows in the board
   */
  public void setBoardSize(int width, int height)
  {
    if (width > getNumCols())
      while (width > getNumCols())
        boardTable.addCol(boardTable.getCol(getNumCols() - 1));
    else if (width < getNumCols())
      while (width < getNumCols())
        boardTable.removeCol(width);
    
    if (height > getNumRows())
      while (height > getNumRows())
        boardTable.addRow(boardTable.getRow(getNumRows() - 1));
    else if (height < getNumRows())
      while (height < getNumRows())
        boardTable.removeRow(height);
  }
}
